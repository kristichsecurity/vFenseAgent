#!/usr/bin/env python

import os
import sys
import time
import socket
import shutil
import urllib2
import platform
import datetime
import traceback
import subprocess
import ConfigParser

from optparse import OptionParser

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))

OPT_DIR = '/opt'
AGENT_DIR = 'agent'
UPDATE_FILE = '.agent_update'

TOPPATCH_DIR = os.path.join(OPT_DIR, 'TopPatch')
AGENT_INSTALL_PATH = os.path.join(TOPPATCH_DIR, AGENT_DIR)
AGENT_CONFIG = os.path.join(AGENT_INSTALL_PATH, 'agent.config')
UPDATE_LOG = os.path.join(TOPPATCH_DIR, 'tmp', 'TopPatchAgentUpdate.log')
INSTALL_LOG = os.path.join(TOPPATCH_DIR, 'agent_install_failure.log')

UNINSTALL_LOG = '/var/log/tpagent_uninstall.log'

AGENT_TMP_LOCATION = os.path.join(TOPPATCH_DIR, 'tmp', AGENT_DIR)

PYTHON_BIN_EXE = os.path.join(AGENT_INSTALL_PATH, 'bin', 'python')

SYSTEM_PYTHON_EXE = '/usr/bin/python'

MAC_PYTHON_EXE = os.path.join(AGENT_INSTALL_PATH,
                              'deps/mac/Python-2.7.5/bin/python')
RPM_PYTHON_EXE = os.path.join(AGENT_INSTALL_PATH,
                              'deps/rpm/Python-2.7.5/bin/python')
RPM6_PYTHON_EXE = os.path.join(AGENT_INSTALL_PATH,
                               'deps/rpm6/Python-2.7.5/bin/python')
RPM_32_PYTHON_EXE = \
    os.path.join(AGENT_INSTALL_PATH, 'deps/rpm-32/Python-2.7.5/bin/python')
RPM6_32_PYTHON_EXE = \
    os.path.join(AGENT_INSTALL_PATH, 'deps/rpm6-32/Python-2.7.5/bin/python')
DEB_PYTHON_EXE = os.path.join(AGENT_INSTALL_PATH,
                              'deps/deb/Python-2.7.5/bin/python')

compiled_python_bit_types = {
    MAC_PYTHON_EXE: '64bit',
    RPM_PYTHON_EXE: '64bit',
    RPM6_PYTHON_EXE: '64bit',
    RPM_32_PYTHON_EXE: '32bit',
    RPM6_32_PYTHON_EXE: '32bit',
    DEB_PYTHON_EXE: '64bit'
}

APP_SETTINGS_SECTION = 'appSettings'
AGENT_INFO_SECTION = 'agentInfo'

RPM_DISTROS = [
    'fedora',
    'centos',
    'centos linux',
    'redhat',
    'red hat enterprise linux server'
]

DEBIAN_DISTROS = ['debian', 'ubuntu', 'linuxmint']

# Defaults when option is not provided to this install script
default_options = {'agentid': '',
                   'nu': '',
                   'wp': '',
                   'serverhostname': '',
                   'serveripaddress': '',
                   'customer': 'default',
                   'serverport': '443',
                   'agentport': '9003',
                   'starterport': '9005',
                   'tunnelport': '22',
                   'loglevel': 'debug',
                   'uninstall_path': '/opt/TopPatch/'}


def run_command(cmd):
    proc = subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE
    )
    result, err = proc.communicate()

    return result, err


def create_necessary_dirs():
    if not os.path.exists(OPT_DIR):
        os.makedirs(OPT_DIR)

    if not os.path.exists(TOPPATCH_DIR):
        os.makedirs(TOPPATCH_DIR)


def write_log(file_path, error):
    log_dir = os.path.dirname(file_path)
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    f = open(file_path, 'a')

    try:
        f.write("%s : %s" % (str(datetime.datetime.now()), str(error)))
        f.write(os.linesep)
    finally:
        f.close()


def write_update_log(message):
    # Will throw an exception if full path cannot be reached due to missing
    # directories.
    write_log(UPDATE_LOG, message)


def write_install_log(message):
    create_necessary_dirs()
    write_log(INSTALL_LOG, message)


def write_uninstall_log(message):
    write_log(UNINSTALL_LOG, message)


def get_date():
    return time.strftime('%m/%d/%Y')


def write_config(config_path, args):
    read_config = ConfigParser.SafeConfigParser()
    write_config = ConfigParser.SafeConfigParser()

    read_config.read(config_path)
    AgentName = read_config.get(AGENT_INFO_SECTION, 'name')
    AgentVersion = read_config.get(AGENT_INFO_SECTION, 'version')
    AgentDescription = read_config.get(AGENT_INFO_SECTION, 'description')

    write_config.add_section(APP_SETTINGS_SECTION)
    write_config.set(APP_SETTINGS_SECTION, 'agentid', args.agentid)
    write_config.set(APP_SETTINGS_SECTION, 'nu', args.username)
    write_config.set(APP_SETTINGS_SECTION, 'wp', args.password)
    write_config.set(
        APP_SETTINGS_SECTION, 'serverhostname', args.serverhostname
    )
    write_config.set(
        APP_SETTINGS_SECTION, 'serveripaddress', args.serveripaddress
    )
    write_config.set(APP_SETTINGS_SECTION, 'serverport', args.serverport)
    write_config.set(APP_SETTINGS_SECTION, 'agentport', args.agentport)
    write_config.set(APP_SETTINGS_SECTION, 'tunnelport', args.tunnelport)
    write_config.set(APP_SETTINGS_SECTION, 'loglevel', args.loglevel)
    write_config.set(APP_SETTINGS_SECTION, 'customer', args.customer)

    write_config.add_section(AGENT_INFO_SECTION)
    write_config.set(AGENT_INFO_SECTION, 'name', AgentName)
    write_config.set(AGENT_INFO_SECTION, 'version', AgentVersion)
    write_config.set(AGENT_INFO_SECTION, 'description', AgentDescription)
    write_config.set(AGENT_INFO_SECTION, 'installdate', get_date())

    f = open(config_path, 'w')

    try:
        write_config.write(f)
    finally:
        f.close()


def get_config_option(config_reader, section, option):
    default = default_options[option]

    try:
        config_option = config_reader.get(section, option)
        return config_option
    except Exception:
        return default


def update_config(args, new_agent_path):

    if '.app' in args.update_path:
        old_config = os.path.join(
            args.update_path, 'Contents', 'Resources', 'agent.config'
        )
    else:
        old_config = os.path.join(args.update_path, 'agent.config')

    read_old_config = ConfigParser.SafeConfigParser()
    read_old_config.read(old_config)

    agentid = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'agentid'
    )

    username = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'nu'
    )

    password = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'wp'
    )

    serverhostname = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'serverhostname'
    )

    serveripaddress = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'serveripaddress'
    )

    serverport = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'serverport'
    )

    starterport = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'starterport'
    )

    tunnelport = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'tunnelport'
    )

    agentport = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'agentport'
    )

    loglevel = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'loglevel'
    )

    customer = get_config_option(
        read_old_config, APP_SETTINGS_SECTION, 'customer'
    )

    if args.agentid:
        agentid = args.agentid

    if args.username:
        username = args.username

    if args.password:
        password = args.password

    if args.serverhostname:
        serverhostname = args.serverhostname

    if args.serveripaddress:
        serveripaddress = args.serveripaddress

    if args.serverport:
        serverport = args.serverport

    if args.starterport:
        starterport = args.starterport

    if args.tunnelport:
        tunnelport = args.tunnelport

    if args.agentport:
        agentport = args.agentport

    if args.loglevel:
        loglevel = args.loglevel

    if args.customer:
        customer = args.customer

    # Grab the agentInfo of the new config
    new_config = os.path.join(new_agent_path, 'agent.config')
    read_new_config = ConfigParser.SafeConfigParser()
    read_new_config.read(new_config)

    name = read_new_config.get(AGENT_INFO_SECTION, 'name')
    version = read_new_config.get(AGENT_INFO_SECTION, 'version')
    description = read_new_config.get(AGENT_INFO_SECTION, 'description')

    write_config = ConfigParser.SafeConfigParser()
    write_config.add_section(APP_SETTINGS_SECTION)
    write_config.set(APP_SETTINGS_SECTION, 'agentid', agentid)
    write_config.set(APP_SETTINGS_SECTION, 'nu', username)
    write_config.set(APP_SETTINGS_SECTION, 'wp', password)
    write_config.set(APP_SETTINGS_SECTION, 'serverhostname', serverhostname)
    write_config.set(APP_SETTINGS_SECTION, 'serveripaddress', serveripaddress)
    write_config.set(APP_SETTINGS_SECTION, 'serverport', serverport)
    write_config.set(APP_SETTINGS_SECTION, 'starterport', starterport)
    write_config.set(APP_SETTINGS_SECTION, 'tunnelport', tunnelport)
    write_config.set(APP_SETTINGS_SECTION, 'agentport', agentport)
    write_config.set(APP_SETTINGS_SECTION, 'loglevel', loglevel)
    write_config.set(APP_SETTINGS_SECTION, 'customer', customer)

    write_config.add_section(AGENT_INFO_SECTION)
    write_config.set(AGENT_INFO_SECTION, 'name', name)
    write_config.set(AGENT_INFO_SECTION, 'version', version)
    write_config.set(AGENT_INFO_SECTION, 'description', description)
    write_config.set(AGENT_INFO_SECTION, 'installdate', get_date())

    f = open(new_config, 'w')

    try:
        write_config.write(f)
    finally:
        f.close()


def create_symlink(symlink_target, symlink_path):
    cmd = ['/bin/ln', '-s', symlink_target, symlink_path]
    result, err = run_command(cmd)

    if err:
        raise Exception(err)


def delete_directory(path):
    if os.path.exists(path):
        shutil.rmtree(path)


def dict_to_json(dictionary):
    """
    Basic dictionary to JSON converter. Does not check types, turns
    everything into a string on json.
    """
    json = []

    json.append("{")

    for k in dictionary:
        json.append('"' + k + '"')
        json.append(':')
        json.append('"' + dictionary[k] + '"')
        json.append(',')

    # Change the last comma to a closing brace
    json[-1] = "}"

    return ''.join(json)


def write_operation_success(app_id, operation_id, success, path):
    root = {}
    root['app_id'] = app_id
    root['operation_id'] = operation_id
    root['success'] = success

    json = dict_to_json(root)

    write_update_log(json)

    f = open(path, 'w')

    try:
        f.write(json)
    finally:
        f.close()


def printErrors(errors):
    sys.stderr.write("Error(s):\n")

    for e in errors:
        sys.stderr.write("    - %s\n" % e)

    sys.exit(1)


def verify_credentials(username, password, server_address):
    """
    Returns message corresponding to error code, if any. If an unknown error
    occured, it will pass the exception. Returns empty string on a 200.
    """
    url = "https://%s/rvl/login" % server_address

    data = {}
    data['name'] = username
    data['password'] = password

    data_json = dict_to_json(data)

    req = urllib2.Request(
        url, data_json, {'Content-Type': 'application/json'}
    )

    try:
        # Stop attempting to open url after 15 seconds
        socket.setdefaulttimeout(15)

        f = urllib2.urlopen(req)
        f.close()

    except urllib2.HTTPError, e:
        known_errors = {
            403: "Invalid username and/or password",
            500: "500 Internal server error",
            502: "502 Bad gateway"
        }

        if e.code in known_errors:
            return known_errors[e.code]
        else:
            return str(e)
    except urllib2.URLError, e:
        if isinstance(e[0], socket.gaierror):
            return "Unknown server address: \"%s\"" % server_address
        elif isinstance(e[0], socket.timeout):
            return "Timed out attempting to reach: \"%s\"" % server_address
        elif isinstance(e[0], socket.error):
            return "Failed to reach: \"%s\"" % server_address
        else:
            return str(e)
    except Exception, e:
        return str(e)

    return ''


def check_user_input(args):
    if args.no_verify:
        return

    errors = []

    if not args.username or not args.password:
        errors.append(
            ("Please provide both username and password to -u and -p, "
             "respectively")
        )

    if not args.serverhostname and not args.serveripaddress:
        errors.append(
            "Please provide server hostname to -s OR server ip address to -i"
        )

    # Stop here if any errors
    if errors:
        printErrors(errors)

    if args.serverhostname:
        server_address = args.serverhostname
    else:
        server_address = args.serveripaddress

    cred_err = verify_credentials(args.username, args.password, server_address)

    # Terminate on invalid credentials
    if cred_err:
        printErrors([cred_err])


class MacUtils:
    def __init__(self):
        self.system_daemon_path = '/Library/LaunchDaemons'
        self.daemon_plist_name = 'com.toppatch.agent.plist'
        self.system_plist = os.path.join(
            self.system_daemon_path, self.daemon_plist_name
        )

    def _unload_plist(self, path):
        cmd = ['/bin/launchctl', 'unload', path]
        result, err = run_command(cmd)

        return True

    def _stop_running_plist(self):
        try:
            if os.path.exists(self.system_plist):
                self._unload_plist(self.system_plist)
                # TODO: no need to delete, since the install overwrites?
        except Exception:
            write_install_log('Failed to remove running agent.')

    def _load_plist(self, path):
        cmd = ['/bin/launchctl', 'load', '-w', path]
        result, err = run_command(cmd)

        if err:
            raise Exception(err)

    def _clean_up(self):
        self._stop_running_plist()

        if os.path.exists(self.system_plist):
            os.remove(self.system_plist)

        delete_directory(AGENT_INSTALL_PATH)

    def install(self, args):
        errors = []

        check_user_input(args)

        try:
            self._clean_up()
            create_necessary_dirs()

            # Copy the agent directory to install path
            shutil.copytree(
                os.path.join(CURRENT_DIR, AGENT_DIR), AGENT_INSTALL_PATH
            )

            # write to agent.config
            write_config(AGENT_CONFIG, args)

            # Copy agent plist to system, this also overwrites
            agent_plist_path = os.path.join(
                AGENT_INSTALL_PATH, 'daemon', 'mac', self.daemon_plist_name
            )
            shutil.copy(agent_plist_path, self.system_daemon_path)

            # Create symlink to corresponding compiled python
            create_symlink(MAC_PYTHON_EXE, PYTHON_BIN_EXE)

            # Run agent's plist
            self._load_plist(
                os.path.join(self.system_daemon_path, self.daemon_plist_name)
            )

        except Exception, e:
            errors.append(
                "Failure when installing agent. See %s for details." %
                INSTALL_LOG
            )
            write_install_log(e)
            write_install_log(traceback.format_exc())

            try:

                self._clean_up()

            except Exception, e2:
                errors.append(
                    "Failure when cleaning up. See %s for details." %
                    INSTALL_LOG
                )
                write_install_log(e2)
                write_install_log(traceback.format_exc())

        if errors:
            printErrors(errors)

    def _overwrite_system_daemon_plist(self, agent_path):
        plist_path = os.path.join('daemon', 'mac', self.daemon_plist_name)
        shutil.copy(os.path.join(agent_path, plist_path), self.system_plist)

    def eject_dmg(self, mount_point):
        """Ejects the mount point give.

        Args:

            - mount_point: Mount point to eject. (ie: /Volumes/Image.dmg)

        Returns:

            - True if ejected successfully; False otherwise.
        """

        cmd = ['/usr/bin/hdiutil', 'detach', '-force', mount_point]
        ejected = False

        try:

            raw_output, _ = run_command(cmd)

            error_message = ''

            for line in raw_output.splitlines():

                if 'ejected' in line:

                    ejected = True
                    break

                else:

                    error_message += line

        except Exception, e:
            raise Exception(e)

        return ejected

    def update(self, args):
        try:
            create_necessary_dirs()

            # Unload old agent plist
            self._unload_plist(self.system_plist)
            write_update_log("Unloaded old daemon process.")

            # Move the applciation from image to temporary folder.
            # Allows copying over old config without deleting old agent, yet.
            delete_directory(AGENT_TMP_LOCATION)  # delete if already exists
            shutil.copytree(
                os.path.join(CURRENT_DIR, AGENT_DIR), AGENT_TMP_LOCATION
            )
            write_update_log("Copied the new agent to tmp directory.")

            update_config(args, AGENT_TMP_LOCATION)
            write_update_log("Copied/updated old config file.")

            vine_settings = os.path.join(
                args.update_path, 'etc', '.vinesettings'
            )
            if os.path.exists(vine_settings):
                tmp_etc = os.path.join(AGENT_TMP_LOCATION, 'etc')

                if not os.path.exists(tmp_etc):
                    os.makedirs(tmp_etc)

                tmp_vnc_path = os.path.join(tmp_etc, '.vinesettings')

                # If it exists, copy it over to the new agent.
                shutil.copy(vine_settings, tmp_vnc_path)

            self._overwrite_system_daemon_plist(AGENT_TMP_LOCATION)
            write_update_log("Agent plist has been overwritten.")

            delete_directory(args.update_path)
            write_update_log("Deleted old agent.")

            shutil.move(AGENT_TMP_LOCATION, AGENT_INSTALL_PATH)
            write_update_log("Moved new agent to /opt directory.")

            create_symlink(MAC_PYTHON_EXE, PYTHON_BIN_EXE)
            write_update_log("Created symlink.")

            self._load_plist(self.system_plist)
            write_update_log("Loaded plist.")

            # TODO: Improve the message passing between old and new agent.
            # Passing appid and operationid as arguments doesn't seem right.
            write_update_log("%s , %s" % (args.appid, args.operationid))
            if args.appid and args.operationid:
                etc_path = os.path.join(AGENT_INSTALL_PATH, 'etc')
                success = 'true'

                write_update_log("etc_path: %s" % etc_path)

                if not os.path.exists(etc_path):
                    os.makedirs(etc_path)

                update_file = os.path.join(etc_path, UPDATE_FILE)

                write_update_log("update_file: %s" % update_file)

                write_operation_success(
                    args.appid, args.operationid, success, update_file
                )

            # Clean up
            delete_directory(AGENT_TMP_LOCATION)
            write_update_log("current_dir: %s" % CURRENT_DIR)

            # Change directory so that the dmg this is living in can be
            # unmounted.
            os.chdir('/opt')
            self.eject_dmg(CURRENT_DIR)

        except Exception, e:
            write_update_log(e)
            write_update_log(traceback.format_exc())

            try:
                delete_directory(AGENT_TMP_LOCATION)
            except Exception, e2:
                write_update_log("Failed to remove tmp agent.")
                write_update_log(e2)
                write_update_log(traceback.format_exc())

            self.eject_dmg(CURRENT_DIR)

    def uninstall(self, args):
        try:
            self._unload_plist(self.system_plist)
            write_uninstall_log("Unloaded daemon process.")

            os.remove(self.system_plist)
            write_uninstall_log("Removed system plist.")

            delete_directory(args.uninstall_path)
            write_uninstall_log("Removed directory.")

            # Got this far, remove the log due to no failure
            os.remove(UNINSTALL_LOG)

        except Exception, e:
            write_uninstall_log(e)
            write_uninstall_log(traceback.format_exc())

            printErrors(
                ["Failure when uninstalling agent, see %s for details"
                 % UNINSTALL_LOG]
            )


class RpmUtils:
    def __init__(self):
        self.daemon_name = 'tpagentd'
        self.init_dir = '/etc/init.d/'
        self.chkconfig = '/sbin/chkconfig'
        self.service = '/sbin/service'

        self.rpm_daemon = os.path.join('daemon', 'rpm', self.daemon_name)
        self.system_daemon = os.path.join(self.init_dir, self.daemon_name)

    def _move_daemon_to_init(self, daemon_path):
        shutil.copy(daemon_path, self.init_dir)

    def _add_daemon_to_startup(self):
        cmd = [self.chkconfig, '--add', self.daemon_name]
        output, err = run_command(cmd)
        if err:
            raise Exception(err)

    def _get_compiled_python(self):
        compiled_python = ''

        if os.path.exists(RPM6_PYTHON_EXE):
            compiled_python = RPM6_PYTHON_EXE
        elif os.path.exists(RPM6_32_PYTHON_EXE):
            compiled_python = RPM6_32_PYTHON_EXE
        elif os.path.exists(RPM_32_PYTHON_EXE):
            compiled_python = RPM_32_PYTHON_EXE
        elif os.path.exists(RPM_PYTHON_EXE):
            compiled_python = RPM_PYTHON_EXE

        return compiled_python

    def _rpm_check_run_levels(self):
        cmd = [self.chkconfig, '--list']
        output, err = run_command(cmd)
        if err:
            raise Exception("Could not check agent run levels.")

        correct_levels = \
            ['0:off', '1:off', '2:on', '3:on', '4:on', '5:on', '6:off']

        output = output.splitlines()
        for line in output:
            if line.startswith(self.daemon_name):
                run_levels = line.split()[1:]

                for level in run_levels:
                    if level not in correct_levels:
                        raise Exception(
                            "%s is not a correct run level." % level
                        )

                return  # CORRECT!

        raise Exception("Agent was not found in chkconfig listing.")

    def _stop_agent(self):
        cmd = [self.service, self.daemon_name, 'stop']
        run_command(cmd)

    def _rpm_remove_service(self):
        # No error is thrown if already deleted before
        cmd = [self.chkconfig, '--del', self.daemon_name]
        output, err = run_command(cmd)
        if err:
            if not "No such file or directory" in err:
                raise Exception(err)

    def _clean_up(self):
        self._stop_agent()
        self._rpm_remove_service()

        if os.path.exists(self.system_daemon):
            os.remove(self.system_daemon)

        delete_directory(AGENT_INSTALL_PATH)

    def _start_agent(self):
        cmd = [self.service, self.daemon_name, 'start']

        dev_null = open(os.devnull, 'w')
        try:
            subprocess.call(cmd, stdout=dev_null, stderr=dev_null)
        finally:
            dev_null.close()

    def _check_for_running_agent(self):
        cmd = [self.service, self.daemon_name, 'status']
        output, err = run_command(cmd)

        if "TopPatch Agent is running" not in err:
            raise Exception(err)

    def install(self, args):
        errors = []

        check_user_input(args)

        try:
            self._clean_up()
            create_necessary_dirs()

            # Copy the agent directory to install path
            shutil.copytree(
                os.path.join(CURRENT_DIR, AGENT_DIR), AGENT_INSTALL_PATH
            )

            # write to agent.config
            write_config(AGENT_CONFIG, args)

            # Create symlink to corresponding compiled python
            compiled_python = self._get_compiled_python()
            if compiled_python:
                create_symlink(compiled_python, PYTHON_BIN_EXE)
            else:
                raise IOError("Failed to find the compiled python directory.")

            self._move_daemon_to_init(
                os.path.join(AGENT_INSTALL_PATH, self.rpm_daemon)
            )
            print "Moved daemon to init.d"

            self._add_daemon_to_startup()
            print "Added daemon to startup."

            print "Checking run levels."
            self._rpm_check_run_levels()
            print "Done checking run levels."

            print "Attempting to start agent."
            self._start_agent()
            self._check_for_running_agent()
            print "TopPatch Agent is running."

        except Exception, e:
            write_install_log(e)
            write_install_log(traceback.format_exc())

            errors.append(
                "Failure when installing agent. See %s for details." %
                INSTALL_LOG
            )

            try:
                self._clean_up()

            except Exception, e2:
                write_install_log(e2)
                write_install_log(traceback.format_exc())

                errors.append(
                    "Failure when cleaning up. See %s for details." %
                    INSTALL_LOG
                )

        if errors:
            printErrors(errors)

    def update(self, args):
        try:
            create_necessary_dirs()

            self._stop_agent()
            write_update_log("Stopped agent.")

            # Move the applciation from downloaded dir to temporary dir.
            # Allows copying over old config without deleting old agent, yet.
            delete_directory(AGENT_TMP_LOCATION)  # delete if already exists
            shutil.copytree(
                os.path.join(CURRENT_DIR, AGENT_DIR), AGENT_TMP_LOCATION
            )
            write_update_log("Copied the new agent to tmp directory.")

            update_config(args, AGENT_TMP_LOCATION)
            write_update_log("Copied/updated old config file.")

            vine_settings = os.path.join(
                args.update_path, 'etc', '.vinesettings'
            )
            if os.path.exists(vine_settings):
                tmp_etc = os.path.join(AGENT_TMP_LOCATION, 'etc')

                if not os.path.exists(tmp_etc):
                    os.makedirs(tmp_etc)

                tmp_vnc_path = os.path.join(tmp_etc, '.vinesettings')

                # If it exists, copy it over to the new agent.
                shutil.copy(vine_settings, tmp_vnc_path)

            delete_directory(args.update_path)
            write_update_log("Deleted old agent.")

            shutil.move(AGENT_TMP_LOCATION, AGENT_INSTALL_PATH)
            write_update_log("Moved new agent to /opt directory.")

            # Create symlink to corresponding compiled python
            compiled_python = self._get_compiled_python()
            if compiled_python:
                create_symlink(compiled_python, PYTHON_BIN_EXE)
                write_update_log("Created symlink.")
            else:
                raise IOError("Failed to find the compiled python directory.")

            self._move_daemon_to_init(
                os.path.join(AGENT_INSTALL_PATH, self.rpm_daemon)
            )
            write_update_log("Agent daemon init script overwritten.")

            self._add_daemon_to_startup()
            write_update_log("Added daemon to startup.")

            write_update_log("Checking run levels.")
            self._rpm_check_run_levels()

            write_update_log("Attempting to start agent.")
            self._start_agent()
            self._check_for_running_agent()
            write_update_log("TopPatch Agent is running.")

            # TODO: Improve the message passing between old and new agent.
            # Passing appid and operationid as arguments doesn't seem right.
            write_update_log("%s , %s" % (args.appid, args.operationid))
            if args.appid and args.operationid:
                etc_path = os.path.join(AGENT_INSTALL_PATH, 'etc')
                success = 'true'

                write_update_log("etc_path: %s" % etc_path)

                if not os.path.exists(etc_path):
                    os.makedirs(etc_path)

                update_file = os.path.join(etc_path, UPDATE_FILE)

                write_update_log("update_file: %s" % update_file)

                write_operation_success(
                    args.appid, args.operationid, success, update_file
                )

            # Clean up tmp dir
            delete_directory(AGENT_TMP_LOCATION)
            write_update_log("current_dir: %s" % CURRENT_DIR)

            # Remove the downloaded update dir
            delete_directory(CURRENT_DIR)

        except Exception, e:
            write_update_log(e)
            write_update_log(traceback.format_exc())

            try:
                delete_directory(AGENT_TMP_LOCATION)
            except Exception, e2:
                write_update_log("Failed to remove tmp agent.")
                write_update_log(e2)
                write_update_log(traceback.format_exc())

            delete_directory(CURRENT_DIR)

    def uninstall(self, args):
        try:
            self._stop_agent()
            write_uninstall_log("Stopped daemon.")

            self._rpm_remove_service()
            write_uninstall_log("Removed daemon from startup.")

            if os.path.exists(self.system_daemon):
                os.remove(self.system_daemon)
            write_uninstall_log("Removed daemon script from system.")

            delete_directory(args.uninstall_path)
            write_uninstall_log("Removed uninstall path directory.")

            # Got this far, remove the log due to no failure
            os.remove(UNINSTALL_LOG)

        except Exception, e:
            write_uninstall_log(e)
            write_uninstall_log(traceback.format_exc())

            printErrors(
                ["Failure when uninstalling agent, see %s for details"
                 % UNINSTALL_LOG]
            )


class DebUtils:
    def __init__(self):
        self.daemon_name = 'tpagentd'
        self.init_dir = '/etc/init.d/'
        self.service = '/usr/sbin/service'
        self.update_rc = '/usr/sbin/update-rc.d'

        self.deb_daemon = os.path.join('daemon', 'deb', self.daemon_name)
        self.system_daemon = os.path.join(self.init_dir, self.daemon_name)

    def _move_daemon_to_init(self, daemon_path):
        shutil.copy(daemon_path, self.init_dir)

    def _stop_agent(self):
        cmd = [self.service, self.daemon_name, 'stop']
        run_command(cmd)

    def _deb_remove_service(self):
        cmd = [self.update_rc, '-f', self.daemon_name, 'remove']
        output, err = run_command(cmd)
        if err:
            if not "No such file or directory" in err:
                raise Exception(err)

    def _clean_up(self):
        self._stop_agent()
        self._deb_remove_service()

        if os.path.exists(self.system_daemon):
            os.remove(self.system_daemon)

        delete_directory(AGENT_INSTALL_PATH)

    def _add_daemon_to_startup(self):
        cmd = [self.update_rc, self.daemon_name, 'defaults']
        results, err = run_command(cmd)
        if err:
            raise Exception(err)

    def _deb_check_run_levels(self):
        for level in range(2, 6):
            rc_dir = '/etc/rc{0}.d/'.format(level)

            if 'S20tpagentd' in os.listdir(rc_dir):
                pass
            else:
                raise Exception(
                    "S20tpagentd not in /etc/rc{0}.d/".format(level)
                )

    def _start_agent(self):
        cmd = [self.service, self.daemon_name, 'start']
        with open(os.devnull, 'w') as dev_null:
            subprocess.call(cmd, stdout=dev_null, stderr=dev_null)

    def _check_for_running_agent(self):
        cmd = [self.service, self.daemon_name, 'status']
        result, err = run_command(cmd)

        if 'TopPatch Agent is running' not in err:
            raise Exception(err)

    def install(self, args):
        errors = []

        check_user_input(args)

        try:
            self._clean_up()
            create_necessary_dirs()

            # Copy the agent directory to install path
            shutil.copytree(
                os.path.join(CURRENT_DIR, AGENT_DIR), AGENT_INSTALL_PATH
            )

            # write to agent.config
            write_config(AGENT_CONFIG, args)

            create_symlink(SYSTEM_PYTHON_EXE, PYTHON_BIN_EXE)

            self._move_daemon_to_init(
                os.path.join(AGENT_INSTALL_PATH, self.deb_daemon)
            )
            print "Moved daemon to init.d"

            self._add_daemon_to_startup()
            print "Added daemon to startup."

            print "Checking run levels."
            self._deb_check_run_levels()
            print "Done checking run levels."

            print "Attempting to start agent."
            self._start_agent()
            self._check_for_running_agent()
            print "TopPatch Agent is running."

        except Exception, e:
            write_install_log(e)
            write_install_log(traceback.format_exc())

            errors.append(
                "Failure when installing agent. See %s for details." %
                INSTALL_LOG
            )

            try:
                self._clean_up()

            except Exception, e2:
                write_install_log(e2)
                write_install_log(traceback.format_exc())

                errors.append(
                    "Failure when cleaning up. See %s for details." %
                    INSTALL_LOG
                )

        if errors:
            printErrors(errors)

    def update(self, args):
        try:
            create_necessary_dirs()

            self._stop_agent()
            write_update_log("Stopped agent.")

            # Move the applciation from downloaded dir to temporary dir.
            # Allows copying over old config without deleting old agent, yet.
            delete_directory(AGENT_TMP_LOCATION)  # delete if already exists
            shutil.copytree(
                os.path.join(CURRENT_DIR, AGENT_DIR), AGENT_TMP_LOCATION
            )
            write_update_log("Copied the new agent to tmp directory.")

            update_config(args, AGENT_TMP_LOCATION)
            write_update_log("Copied/updated old config file.")

            vine_settings = os.path.join(
                args.update_path, 'etc', '.vinesettings'
            )
            if os.path.exists(vine_settings):
                tmp_etc = os.path.join(AGENT_TMP_LOCATION, 'etc')

                if not os.path.exists(tmp_etc):
                    os.makedirs(tmp_etc)

                tmp_vnc_path = os.path.join(tmp_etc, '.vinesettings')

                # If it exists, copy it over to the new agent.
                shutil.copy(vine_settings, tmp_vnc_path)

            delete_directory(args.update_path)
            write_update_log("Deleted old agent.")

            shutil.move(AGENT_TMP_LOCATION, AGENT_INSTALL_PATH)
            write_update_log("Moved new agent to /opt directory.")

            create_symlink(SYSTEM_PYTHON_EXE, PYTHON_BIN_EXE)
            write_update_log("Created symlink.")

            self._move_daemon_to_init(
                os.path.join(AGENT_INSTALL_PATH, self.deb_daemon)
            )
            write_update_log("Agent daemon init script overwritten.")

            self._add_daemon_to_startup()
            write_update_log("Added daemon to startup.")

            self._deb_check_run_levels()
            write_update_log("Checked run levels.")

            write_update_log("Attempting to start agent.")
            self._start_agent()
            self._check_for_running_agent()
            write_update_log("TopPatch Agent is running.")

            # TODO: Improve the message passing between old and new agent.
            # Passing appid and operationid as arguments doesn't seem right.
            write_update_log("%s , %s" % (args.appid, args.operationid))
            if args.appid and args.operationid:
                etc_path = os.path.join(AGENT_INSTALL_PATH, 'etc')
                success = 'true'

                write_update_log("etc_path: %s" % etc_path)

                if not os.path.exists(etc_path):
                    os.makedirs(etc_path)

                update_file = os.path.join(etc_path, UPDATE_FILE)

                write_update_log("update_file: %s" % update_file)

                write_operation_success(
                    args.appid, args.operationid, success, update_file
                )

            # Clean up tmp dir
            delete_directory(AGENT_TMP_LOCATION)
            write_update_log("current_dir: %s" % CURRENT_DIR)

            # Remove the downloaded update dir
            delete_directory(CURRENT_DIR)

        except Exception, e:
            write_update_log(e)
            write_update_log(traceback.format_exc())

            try:
                delete_directory(AGENT_TMP_LOCATION)
            except Exception, e2:
                write_update_log("Failed to remove tmp agent.")
                write_update_log(e2)
                write_update_log(traceback.format_exc())

            delete_directory(CURRENT_DIR)

    def uninstall(self, args):
        try:
            self._stop_agent()
            write_uninstall_log("Stopped daemon.")

            self._deb_remove_service()
            write_uninstall_log("Removed daemon from startup.")

            if os.path.exists(self.system_daemon):
                os.remove(self.system_daemon)
            write_uninstall_log("Removed daemon script from system.")

            delete_directory(args.uninstall_path)
            write_uninstall_log("Removed uninstall path directory.")

            # Got this far, remove the log due to no failure
            os.remove(UNINSTALL_LOG)

        except Exception, e:
            write_uninstall_log(e)
            write_uninstall_log(traceback.format_exc())

            printErrors(
                ["Failure when uninstalling agent, see %s for details"
                 % UNINSTALL_LOG]
            )

###################################################################
###################################################################
###################################################################


def get_platform():
    return platform.system().lower()


def get_distro():
    plat = get_platform()

    if plat == 'darwin':
        return 'darwin'

    elif plat == 'linux':
        try:
            return platform.linux_distribution()[0].lower()
        except Exception:
            return platform.dist()[0].lower()

    return ''


def get_platform_utils():
    distro = get_distro()

    if distro == 'darwin':
        return MacUtils()

    elif distro in RPM_DISTROS:
        return RpmUtils()

    elif distro in DEBIAN_DISTROS:
        return DebUtils()


def check_privilege():
    """
    Checks for sudo privileges. Exits if it does not have sudo privileges.
    """
    if os.geteuid() != 0:
        printErrors(["Agent utilities must be run as root."])


def get_compiled_python_bit_type():
    for compiled_python in compiled_python_bit_types:
        if os.path.exists(compiled_python):
            return compiled_python_bit_types[compiled_python]

    return None


def check_bit_type():
    """
    Compares system bit type with the compiled python bit type. Terminates
    program if bit types do not match.
    """
    sys_arch = platform.architecture()[0]
    compiled_python_bit_type = get_compiled_python_bit_type()

    if compiled_python_bit_type:
        if compiled_python_bit_type != sys_arch:
            printErrors(
                [("This system appears to be %s, but the agent is %s."
                 " Please install the %s agent."
                 % (sys_arch, compiled_python_bit_type, sys_arch))]
            )
    else:
        # Let it pass, using system python
        pass


def uninstall_op_callback(option, opt, value, parser):
    if len(parser.rargs) > 0:
        if parser.rargs[0].startswith('-'):
            printErrors(
                ["Usage of '-' in beginning of path provided to the %s option."
                 % option]
            )
        else:
            parser.values.uninstall_path = parser.rargs[0]

    else:
        parser.values.uninstall_path = default_options['uninstall_path']

        if os.path.exists(os.path.join(TOPPATCH_DIR, 'tp', 'src')):
            # The agent is living alongside the server, only delete the agent
            parser.values.uninstall_path += AGENT_DIR


def get_input():
    """
    Gets the input from options passed into the install script.
    """
    parser = OptionParser()

    parser.add_option("-u", "--username", dest="username",
                      default=default_options['nu'], help="This is required.")
    parser.add_option("-p", "--password", dest="password",
                      default=default_options['wp'], help="This is required.")
    parser.add_option(
        "-s", "--serverhostname", default=default_options['serverhostname'],
        dest="serverhostname",
        help=("Please provide server hostname and/or server ip address."
              " Only one required.")
    )
    parser.add_option(
        "-i", "--serveripaddress", default=default_options['serveripaddress'],
        dest="serveripaddress",
        help=("Please provide server ip address and/or server hostname."
              " Only one required.")
    )
    parser.add_option("-c", "--customer", default=default_options['customer'],
                      dest="customer", help="Default: default.")
    parser.add_option("--serverport", default=default_options['serverport'],
                      dest="serverport", help="Default: 443.")
    parser.add_option("--agentport", default=default_options['agentport'],
                      dest="agentport", help="Default: 9003.")
    parser.add_option("--starterport", default=default_options['starterport'],
                      dest="starterport", help="Default: 9005.")
    parser.add_option("--tunnelport", default=default_options['tunnelport'],
                      dest="tunnelport", help="Default: 22.")
    parser.add_option("--loglevel", default=default_options['loglevel'],
                      dest="loglevel", help="Default: debug.")

    parser.add_option("--no-verify", action="store_true", default=False,
                      dest="no_verify", help="Do not verify credentials.")

    # If called, provide it with the path to the old agent
    parser.add_option("--update", default="", dest="update_path",
                      help=("Should only be used to flag an update. "
                            "Current agent path must be provided."))
    parser.add_option("--agentid", default="", dest="agentid")
    parser.add_option("--operationid", default="", dest="operationid")
    parser.add_option("--appid", default="", dest="appid")
    parser.add_option("--workingdir", default="", dest="workingdir",
                      help="Use to specify the path to the parent directory of"
                           " the agent application to install.")

    # Must specify type in order to send value to callback
    parser.add_option("--uninstall", default="", action="callback",
                      dest="uninstall_path", callback=uninstall_op_callback,
                      help="Uninstall the agent. Provide path to agent if the "
                           "agent was not installed in the default directory.")

    return parser.parse_args()

if __name__ == '__main__':
    args = get_input()[0]
    utils = get_platform_utils()

    if args.workingdir:
        CURRENT_DIR = args.workingdir

    if args.uninstall_path:
        check_privilege()
        utils.uninstall(args)
    elif args.update_path:
        check_privilege()
        check_bit_type()
        utils.update(args)
    elif args.username or args.password:
        check_privilege()
        check_bit_type()
        utils.install(args)
    else:
        printErrors(["Incorrect usage of script, please use -h for help."])
